
AutoWatererFW.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000482  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000040e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000019  00800100  00800100  00000482  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000482  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000004b4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000058  00000000  00000000  000004f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000c48  00000000  00000000  0000054c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a13  00000000  00000000  00001194  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000044a  00000000  00000000  00001ba7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000b0  00000000  00000000  00001ff4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005db  00000000  00000000  000020a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000056  00000000  00000000  0000267f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000048  00000000  00000000  000026d5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
   4:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
   8:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
   c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  10:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  14:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  18:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  1c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  20:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  24:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  28:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  2c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  30:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  34:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  38:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  3c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  40:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  44:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  48:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  4c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  50:	0c 94 96 01 	jmp	0x32c	; 0x32c <__vector_20>
  54:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  58:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  5c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  60:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  64:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  68:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  6c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  70:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  74:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  78:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  7c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  80:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  84:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  88:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  8c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  90:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  94:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  98:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  9c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  a0:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  a4:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  a8:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	da e0       	ldi	r29, 0x0A	; 10
  b4:	de bf       	out	0x3e, r29	; 62
  b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_clear_bss>:
  b8:	21 e0       	ldi	r18, 0x01	; 1
  ba:	a0 e0       	ldi	r26, 0x00	; 0
  bc:	b1 e0       	ldi	r27, 0x01	; 1
  be:	01 c0       	rjmp	.+2      	; 0xc2 <.do_clear_bss_start>

000000c0 <.do_clear_bss_loop>:
  c0:	1d 92       	st	X+, r1

000000c2 <.do_clear_bss_start>:
  c2:	a9 31       	cpi	r26, 0x19	; 25
  c4:	b2 07       	cpc	r27, r18
  c6:	e1 f7       	brne	.-8      	; 0xc0 <.do_clear_bss_loop>
  c8:	0e 94 64 01 	call	0x2c8	; 0x2c8 <main>
  cc:	0c 94 05 02 	jmp	0x40a	; 0x40a <_exit>

000000d0 <__bad_interrupt>:
  d0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d4 <Init_IO>:
//Local variables
volatile uint8_t pumpRequests = 0;

void Init_IO(){
	//Initialize IO ports
	DDRB |= 0b00010000;
  d4:	24 9a       	sbi	0x04, 4	; 4
	DDRC |= 0b00000000;
  d6:	87 b1       	in	r24, 0x07	; 7
  d8:	87 b9       	out	0x07, r24	; 7
	DDRD |= 0b00100000;
  da:	55 9a       	sbi	0x0a, 5	; 10
	
	PORTB |= 0b01000000;
  dc:	2e 9a       	sbi	0x05, 6	; 5
	PORTC |= 0b00000000;
  de:	88 b1       	in	r24, 0x08	; 8
  e0:	88 b9       	out	0x08, r24	; 8
	PORTD |= 0b00000000;
  e2:	8b b1       	in	r24, 0x0b	; 11
  e4:	8b b9       	out	0x0b, r24	; 11
  e6:	08 95       	ret

000000e8 <Init_Timer>:
void Init_Timer()
{
	//Initialize timer
	
	//1ms timer
	TCCR1A |= (0 << COM1A1) | (0 << COM1A0) | (0 << COM1B1) | (0 << COM1B0) | (1 << WGM11) | (0 << WGM10);	//Non-inverting PWM, fast PWM mode
  e8:	e0 e8       	ldi	r30, 0x80	; 128
  ea:	f0 e0       	ldi	r31, 0x00	; 0
  ec:	80 81       	ld	r24, Z
  ee:	82 60       	ori	r24, 0x02	; 2
  f0:	80 83       	st	Z, r24
	TCCR1B |= (0 << ICNC1) | (0 << ICES1) | (1 << WGM13) | (1 << WGM12) | (0 << CS12) | (1 << CS11) | (1 << CS10);			//ICR1 = TOP, 8x prescaler
  f2:	e1 e8       	ldi	r30, 0x81	; 129
  f4:	f0 e0       	ldi	r31, 0x00	; 0
  f6:	80 81       	ld	r24, Z
  f8:	8b 61       	ori	r24, 0x1B	; 27
  fa:	80 83       	st	Z, r24
	TIMSK1 |= (1 << TOIE1);
  fc:	ef e6       	ldi	r30, 0x6F	; 111
  fe:	f0 e0       	ldi	r31, 0x00	; 0
 100:	80 81       	ld	r24, Z
 102:	81 60       	ori	r24, 0x01	; 1
 104:	80 83       	st	Z, r24
	ICR1 = 249;		//249 = 1kHz, 1ms period
 106:	89 ef       	ldi	r24, 0xF9	; 249
 108:	90 e0       	ldi	r25, 0x00	; 0
 10a:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
 10e:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
 112:	08 95       	ret

00000114 <Init_ADC>:
	
}
void Init_ADC()
{
	//Initialize the ADC
	ADMUX |= 0x41;	//Set AVCC as reference and ADC1 as input
 114:	ec e7       	ldi	r30, 0x7C	; 124
 116:	f0 e0       	ldi	r31, 0x00	; 0
 118:	80 81       	ld	r24, Z
 11a:	81 64       	ori	r24, 0x41	; 65
 11c:	80 83       	st	Z, r24
	ADCSRA |= (1 << ADEN) | (1 << ADSC) | (1 << ADATE) | (0 << ADPS1) | (1 << ADPS0);		//Enable ADC, start conversion, enable auto triggering, clk/2 prescaler
 11e:	ea e7       	ldi	r30, 0x7A	; 122
 120:	f0 e0       	ldi	r31, 0x00	; 0
 122:	80 81       	ld	r24, Z
 124:	81 6e       	ori	r24, 0xE1	; 225
 126:	80 83       	st	Z, r24
	ADCSRB = 0x00;
 128:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
 12c:	08 95       	ret

0000012e <checkTimerKnob>:
void checkTimerKnob()
{
	//Check timer knob ADC and adjust frequency of sprays
	//86,400 = 1 day/24 hours
	//3600 = 1 hour
	if ((pumpSchedTop < adcScaler - 10) || (pumpSchedTop > adcScaler + 10))
 12e:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 132:	30 91 79 00 	lds	r19, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 136:	40 91 01 01 	lds	r20, 0x0101	; 0x800101 <pumpSchedTop>
 13a:	50 91 02 01 	lds	r21, 0x0102	; 0x800102 <pumpSchedTop+0x1>
 13e:	60 91 03 01 	lds	r22, 0x0103	; 0x800103 <pumpSchedTop+0x2>
 142:	70 91 04 01 	lds	r23, 0x0104	; 0x800104 <pumpSchedTop+0x3>
 146:	e9 ea       	ldi	r30, 0xA9	; 169
 148:	e2 9f       	mul	r30, r18
 14a:	c0 01       	movw	r24, r0
 14c:	e3 9f       	mul	r30, r19
 14e:	90 0d       	add	r25, r0
 150:	11 24       	eor	r1, r1
 152:	0a 97       	sbiw	r24, 0x0a	; 10
 154:	a0 e0       	ldi	r26, 0x00	; 0
 156:	b0 e0       	ldi	r27, 0x00	; 0
 158:	48 17       	cp	r20, r24
 15a:	59 07       	cpc	r21, r25
 15c:	6a 07       	cpc	r22, r26
 15e:	7b 07       	cpc	r23, r27
 160:	c8 f0       	brcs	.+50     	; 0x194 <checkTimerKnob+0x66>
 162:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 166:	30 91 79 00 	lds	r19, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 16a:	40 91 01 01 	lds	r20, 0x0101	; 0x800101 <pumpSchedTop>
 16e:	50 91 02 01 	lds	r21, 0x0102	; 0x800102 <pumpSchedTop+0x1>
 172:	60 91 03 01 	lds	r22, 0x0103	; 0x800103 <pumpSchedTop+0x2>
 176:	70 91 04 01 	lds	r23, 0x0104	; 0x800104 <pumpSchedTop+0x3>
 17a:	e2 9f       	mul	r30, r18
 17c:	c0 01       	movw	r24, r0
 17e:	e3 9f       	mul	r30, r19
 180:	90 0d       	add	r25, r0
 182:	11 24       	eor	r1, r1
 184:	0a 96       	adiw	r24, 0x0a	; 10
 186:	a0 e0       	ldi	r26, 0x00	; 0
 188:	b0 e0       	ldi	r27, 0x00	; 0
 18a:	84 17       	cp	r24, r20
 18c:	95 07       	cpc	r25, r21
 18e:	a6 07       	cpc	r26, r22
 190:	b7 07       	cpc	r27, r23
 192:	48 f5       	brcc	.+82     	; 0x1e6 <checkTimerKnob+0xb8>
	{
		//Knob has moved, reset timer and modify top and ensure pump is off (in case of change while pump running
		pumpSchedTop = adcScaler;
 194:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 198:	30 91 79 00 	lds	r19, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 19c:	49 ea       	ldi	r20, 0xA9	; 169
 19e:	42 9f       	mul	r20, r18
 1a0:	c0 01       	movw	r24, r0
 1a2:	43 9f       	mul	r20, r19
 1a4:	90 0d       	add	r25, r0
 1a6:	11 24       	eor	r1, r1
 1a8:	a0 e0       	ldi	r26, 0x00	; 0
 1aa:	b0 e0       	ldi	r27, 0x00	; 0
 1ac:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <pumpSchedTop>
 1b0:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <pumpSchedTop+0x1>
 1b4:	a0 93 03 01 	sts	0x0103, r26	; 0x800103 <pumpSchedTop+0x2>
 1b8:	b0 93 04 01 	sts	0x0104, r27	; 0x800104 <pumpSchedTop+0x3>
		pumpRequests &= ~(1 << pumpReq);
 1bc:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 1c0:	8d 7f       	andi	r24, 0xFD	; 253
 1c2:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
		pumpSchedCtr = 0;
 1c6:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <pumpSchedCtr>
 1ca:	10 92 0a 01 	sts	0x010A, r1	; 0x80010a <pumpSchedCtr+0x1>
 1ce:	10 92 0b 01 	sts	0x010B, r1	; 0x80010b <pumpSchedCtr+0x2>
 1d2:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <pumpSchedCtr+0x3>
		pumpRunCtr = 0;
 1d6:	10 92 05 01 	sts	0x0105, r1	; 0x800105 <pumpRunCtr>
 1da:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <pumpRunCtr+0x1>
 1de:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <pumpRunCtr+0x2>
 1e2:	10 92 08 01 	sts	0x0108, r1	; 0x800108 <pumpRunCtr+0x3>
 1e6:	08 95       	ret

000001e8 <pumpScheduler>:
	}
}
void pumpScheduler()
{
	//Pump scheduler, run every 1s
	if (pumpSchedCtr < pumpSchedTop)
 1e8:	40 91 09 01 	lds	r20, 0x0109	; 0x800109 <pumpSchedCtr>
 1ec:	50 91 0a 01 	lds	r21, 0x010A	; 0x80010a <pumpSchedCtr+0x1>
 1f0:	60 91 0b 01 	lds	r22, 0x010B	; 0x80010b <pumpSchedCtr+0x2>
 1f4:	70 91 0c 01 	lds	r23, 0x010C	; 0x80010c <pumpSchedCtr+0x3>
 1f8:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <pumpSchedTop>
 1fc:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <pumpSchedTop+0x1>
 200:	a0 91 03 01 	lds	r26, 0x0103	; 0x800103 <pumpSchedTop+0x2>
 204:	b0 91 04 01 	lds	r27, 0x0104	; 0x800104 <pumpSchedTop+0x3>
 208:	48 17       	cp	r20, r24
 20a:	59 07       	cpc	r21, r25
 20c:	6a 07       	cpc	r22, r26
 20e:	7b 07       	cpc	r23, r27
 210:	a0 f4       	brcc	.+40     	; 0x23a <pumpScheduler+0x52>
	{
		pumpSchedCtr++;
 212:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <pumpSchedCtr>
 216:	90 91 0a 01 	lds	r25, 0x010A	; 0x80010a <pumpSchedCtr+0x1>
 21a:	a0 91 0b 01 	lds	r26, 0x010B	; 0x80010b <pumpSchedCtr+0x2>
 21e:	b0 91 0c 01 	lds	r27, 0x010C	; 0x80010c <pumpSchedCtr+0x3>
 222:	01 96       	adiw	r24, 0x01	; 1
 224:	a1 1d       	adc	r26, r1
 226:	b1 1d       	adc	r27, r1
 228:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <pumpSchedCtr>
 22c:	90 93 0a 01 	sts	0x010A, r25	; 0x80010a <pumpSchedCtr+0x1>
 230:	a0 93 0b 01 	sts	0x010B, r26	; 0x80010b <pumpSchedCtr+0x2>
 234:	b0 93 0c 01 	sts	0x010C, r27	; 0x80010c <pumpSchedCtr+0x3>
 238:	08 95       	ret
	}
	else
	{
		//Timer overflow, run spray cycle
		if (pumpRunCtr <= sprayTimeSec)
 23a:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <pumpRunCtr>
 23e:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <pumpRunCtr+0x1>
 242:	a0 91 07 01 	lds	r26, 0x0107	; 0x800107 <pumpRunCtr+0x2>
 246:	b0 91 08 01 	lds	r27, 0x0108	; 0x800108 <pumpRunCtr+0x3>
 24a:	06 97       	sbiw	r24, 0x06	; 6
 24c:	a1 05       	cpc	r26, r1
 24e:	b1 05       	cpc	r27, r1
 250:	c8 f4       	brcc	.+50     	; 0x284 <pumpScheduler+0x9c>
		{
			pumpRunCtr++;
 252:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <pumpRunCtr>
 256:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <pumpRunCtr+0x1>
 25a:	a0 91 07 01 	lds	r26, 0x0107	; 0x800107 <pumpRunCtr+0x2>
 25e:	b0 91 08 01 	lds	r27, 0x0108	; 0x800108 <pumpRunCtr+0x3>
 262:	01 96       	adiw	r24, 0x01	; 1
 264:	a1 1d       	adc	r26, r1
 266:	b1 1d       	adc	r27, r1
 268:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <pumpRunCtr>
 26c:	90 93 06 01 	sts	0x0106, r25	; 0x800106 <pumpRunCtr+0x1>
 270:	a0 93 07 01 	sts	0x0107, r26	; 0x800107 <pumpRunCtr+0x2>
 274:	b0 93 08 01 	sts	0x0108, r27	; 0x800108 <pumpRunCtr+0x3>
			pumpRequests |= (1 << pumpReq);
 278:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 27c:	82 60       	ori	r24, 0x02	; 2
 27e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
 282:	08 95       	ret
		}
		else
		{
			pumpRequests &= ~(1 << pumpReq);
 284:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 288:	8d 7f       	andi	r24, 0xFD	; 253
 28a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
			pumpSchedCtr = 0;
 28e:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <pumpSchedCtr>
 292:	10 92 0a 01 	sts	0x010A, r1	; 0x80010a <pumpSchedCtr+0x1>
 296:	10 92 0b 01 	sts	0x010B, r1	; 0x80010b <pumpSchedCtr+0x2>
 29a:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <pumpSchedCtr+0x3>
			pumpRunCtr = 0;
 29e:	10 92 05 01 	sts	0x0105, r1	; 0x800105 <pumpRunCtr>
 2a2:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <pumpRunCtr+0x1>
 2a6:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <pumpRunCtr+0x2>
 2aa:	10 92 08 01 	sts	0x0108, r1	; 0x800108 <pumpRunCtr+0x3>
 2ae:	08 95       	ret

000002b0 <controlPump>:
	}
}
void controlPump()
{
	//Control pump based on global variables
	if ((pumpRequests & (1 << pumpOvr)) || (pumpRequests & (1 << pumpReq)))
 2b0:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 2b4:	80 fd       	sbrc	r24, 0
 2b6:	04 c0       	rjmp	.+8      	; 0x2c0 <controlPump+0x10>
 2b8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 2bc:	81 ff       	sbrs	r24, 1
 2be:	02 c0       	rjmp	.+4      	; 0x2c4 <controlPump+0x14>
	{
		Pump_ON;
 2c0:	5d 9a       	sbi	0x0b, 5	; 11
 2c2:	08 95       	ret
	}
	else
	{
		Pump_OFF;
 2c4:	5d 98       	cbi	0x0b, 5	; 11
 2c6:	08 95       	ret

000002c8 <main>:
	}
}

int main(void)
{
	Init_IO();
 2c8:	0e 94 6a 00 	call	0xd4	; 0xd4 <Init_IO>
	Init_Timer();
 2cc:	0e 94 74 00 	call	0xe8	; 0xe8 <Init_Timer>
	Init_ADC();
 2d0:	0e 94 8a 00 	call	0x114	; 0x114 <Init_ADC>
	sei();
 2d4:	78 94       	sei
	while (1) 
	{
		//Scheduler
		if (t10mSecCtr)
 2d6:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <t10mSecCtr>
 2da:	88 23       	and	r24, r24
 2dc:	21 f0       	breq	.+8      	; 0x2e6 <main+0x1e>
		{
			//Do 10msec tasks and reset scheduler
			controlPump();
 2de:	0e 94 58 01 	call	0x2b0	; 0x2b0 <controlPump>
			//Reset scheduler tick
			t10mSecCtr = 0;
 2e2:	10 92 18 01 	sts	0x0118, r1	; 0x800118 <t10mSecCtr>
		}//if (t10mSecCtr)
		
		if (t100mSecCtr)
 2e6:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <t100mSecCtr>
 2ea:	88 23       	and	r24, r24
 2ec:	89 f0       	breq	.+34     	; 0x310 <main+0x48>
		{
			//Do 100msec tasks and reset scheduler
			checkTimerKnob();
 2ee:	0e 94 97 00 	call	0x12e	; 0x12e <checkTimerKnob>
			//Turn pump on with button
			if (readButton1)
 2f2:	1e 99       	sbic	0x03, 6	; 3
 2f4:	06 c0       	rjmp	.+12     	; 0x302 <main+0x3a>
			{
				pumpRequests |= (1 << pumpOvr);
 2f6:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 2fa:	81 60       	ori	r24, 0x01	; 1
 2fc:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
 300:	05 c0       	rjmp	.+10     	; 0x30c <main+0x44>
			}
			else pumpRequests &= ~(1 << pumpOvr);
 302:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 306:	8e 7f       	andi	r24, 0xFE	; 254
 308:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
			
			//Reset scheduler tick
			t100mSecCtr = 0;
 30c:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <t100mSecCtr>
		} //if (t100mSecCtr)
		
		if (t500mSecCtr)
 310:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <t500mSecCtr>
 314:	81 11       	cpse	r24, r1
		{
			//Do 500msec tasks and reset scheduler
			t500mSecCtr = 0;
 316:	10 92 16 01 	sts	0x0116, r1	; 0x800116 <t500mSecCtr>
		}//if (t500mSecCtr)
		
		if (t1SecCtr)
 31a:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <t1SecCtr>
 31e:	88 23       	and	r24, r24
 320:	d1 f2       	breq	.-76     	; 0x2d6 <main+0xe>
		{
			//Do 1sec tasks and reset scheduler
			pumpScheduler();
 322:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <pumpScheduler>
			t1SecCtr = 0;
 326:	10 92 15 01 	sts	0x0115, r1	; 0x800115 <t1SecCtr>
 32a:	d5 cf       	rjmp	.-86     	; 0x2d6 <main+0xe>

0000032c <__vector_20>:
		}//if (t1SecCtr)
	}
}

ISR(TIMER1_OVF_vect){
 32c:	1f 92       	push	r1
 32e:	0f 92       	push	r0
 330:	0f b6       	in	r0, 0x3f	; 63
 332:	0f 92       	push	r0
 334:	11 24       	eor	r1, r1
 336:	2f 93       	push	r18
 338:	8f 93       	push	r24
 33a:	9f 93       	push	r25
	//Executes every 1ms
	
	//Scheduler
	if (Timer10msOld < 10)
 33c:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <Timer10msOld>
 340:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <Timer10msOld+0x1>
 344:	0a 97       	sbiw	r24, 0x0a	; 10
 346:	50 f4       	brcc	.+20     	; 0x35c <__vector_20+0x30>
	{
		Timer10msOld++;
 348:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <Timer10msOld>
 34c:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <Timer10msOld+0x1>
 350:	01 96       	adiw	r24, 0x01	; 1
 352:	90 93 14 01 	sts	0x0114, r25	; 0x800114 <Timer10msOld+0x1>
 356:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <Timer10msOld>
 35a:	07 c0       	rjmp	.+14     	; 0x36a <__vector_20+0x3e>
	}
	else
	{
		t10mSecCtr = 1;
 35c:	81 e0       	ldi	r24, 0x01	; 1
 35e:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <t10mSecCtr>
		Timer10msOld = 0;
 362:	10 92 14 01 	sts	0x0114, r1	; 0x800114 <Timer10msOld+0x1>
 366:	10 92 13 01 	sts	0x0113, r1	; 0x800113 <Timer10msOld>
	}
	
	if (Timer100msOld < 100)
 36a:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <Timer100msOld>
 36e:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <Timer100msOld+0x1>
 372:	84 36       	cpi	r24, 0x64	; 100
 374:	91 05       	cpc	r25, r1
 376:	50 f4       	brcc	.+20     	; 0x38c <__vector_20+0x60>
	{
		Timer100msOld++;
 378:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <Timer100msOld>
 37c:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <Timer100msOld+0x1>
 380:	01 96       	adiw	r24, 0x01	; 1
 382:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <Timer100msOld+0x1>
 386:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <Timer100msOld>
 38a:	07 c0       	rjmp	.+14     	; 0x39a <__vector_20+0x6e>
	}
	else
	{
		t100mSecCtr = 1;
 38c:	81 e0       	ldi	r24, 0x01	; 1
 38e:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <t100mSecCtr>
		Timer100msOld = 0;
 392:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <Timer100msOld+0x1>
 396:	10 92 11 01 	sts	0x0111, r1	; 0x800111 <Timer100msOld>
	}
	
	if (Timer500msOld < 500)
 39a:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <Timer500msOld>
 39e:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <Timer500msOld+0x1>
 3a2:	84 3f       	cpi	r24, 0xF4	; 244
 3a4:	91 40       	sbci	r25, 0x01	; 1
 3a6:	50 f4       	brcc	.+20     	; 0x3bc <__vector_20+0x90>
	{
		Timer500msOld++;
 3a8:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <Timer500msOld>
 3ac:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <Timer500msOld+0x1>
 3b0:	01 96       	adiw	r24, 0x01	; 1
 3b2:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <Timer500msOld+0x1>
 3b6:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <Timer500msOld>
 3ba:	07 c0       	rjmp	.+14     	; 0x3ca <__vector_20+0x9e>
	}
	else
	{
		t500mSecCtr = 1;
 3bc:	81 e0       	ldi	r24, 0x01	; 1
 3be:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <t500mSecCtr>
		Timer500msOld = 0;
 3c2:	10 92 10 01 	sts	0x0110, r1	; 0x800110 <Timer500msOld+0x1>
 3c6:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <Timer500msOld>
	}
	
	if (Timer1sOld < 1000)
 3ca:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <Timer1sOld>
 3ce:	90 91 0e 01 	lds	r25, 0x010E	; 0x80010e <Timer1sOld+0x1>
 3d2:	88 3e       	cpi	r24, 0xE8	; 232
 3d4:	93 40       	sbci	r25, 0x03	; 3
 3d6:	50 f4       	brcc	.+20     	; 0x3ec <__vector_20+0xc0>
	{
		Timer1sOld++;
 3d8:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <Timer1sOld>
 3dc:	90 91 0e 01 	lds	r25, 0x010E	; 0x80010e <Timer1sOld+0x1>
 3e0:	01 96       	adiw	r24, 0x01	; 1
 3e2:	90 93 0e 01 	sts	0x010E, r25	; 0x80010e <Timer1sOld+0x1>
 3e6:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <Timer1sOld>
 3ea:	07 c0       	rjmp	.+14     	; 0x3fa <__vector_20+0xce>
	}
	else
	{
		t1SecCtr = 1;
 3ec:	81 e0       	ldi	r24, 0x01	; 1
 3ee:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <t1SecCtr>
		Timer1sOld = 0;
 3f2:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <Timer1sOld+0x1>
 3f6:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <Timer1sOld>
	}
 3fa:	9f 91       	pop	r25
 3fc:	8f 91       	pop	r24
 3fe:	2f 91       	pop	r18
 400:	0f 90       	pop	r0
 402:	0f be       	out	0x3f, r0	; 63
 404:	0f 90       	pop	r0
 406:	1f 90       	pop	r1
 408:	18 95       	reti

0000040a <_exit>:
 40a:	f8 94       	cli

0000040c <__stop_program>:
 40c:	ff cf       	rjmp	.-2      	; 0x40c <__stop_program>
